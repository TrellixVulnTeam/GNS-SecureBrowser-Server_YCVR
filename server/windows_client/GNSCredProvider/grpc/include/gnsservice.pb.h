// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gnsservice.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gnsservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gnsservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gnsservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gnsservice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gnsservice_2eproto;
namespace GNSRPC {
class CardStatus;
struct CardStatusDefaultTypeInternal;
extern CardStatusDefaultTypeInternal _CardStatus_default_instance_;
class FreeSites;
struct FreeSitesDefaultTypeInternal;
extern FreeSitesDefaultTypeInternal _FreeSites_default_instance_;
class FreeWinCreds;
struct FreeWinCredsDefaultTypeInternal;
extern FreeWinCredsDefaultTypeInternal _FreeWinCreds_default_instance_;
class GNSBadgeDataParam;
struct GNSBadgeDataParamDefaultTypeInternal;
extern GNSBadgeDataParamDefaultTypeInternal _GNSBadgeDataParam_default_instance_;
class SiteCred;
struct SiteCredDefaultTypeInternal;
extern SiteCredDefaultTypeInternal _SiteCred_default_instance_;
class Sites;
struct SitesDefaultTypeInternal;
extern SitesDefaultTypeInternal _Sites_default_instance_;
class Text;
struct TextDefaultTypeInternal;
extern TextDefaultTypeInternal _Text_default_instance_;
class UUID;
struct UUIDDefaultTypeInternal;
extern UUIDDefaultTypeInternal _UUID_default_instance_;
class WinCred;
struct WinCredDefaultTypeInternal;
extern WinCredDefaultTypeInternal _WinCred_default_instance_;
class WinCreds;
struct WinCredsDefaultTypeInternal;
extern WinCredsDefaultTypeInternal _WinCreds_default_instance_;
}  // namespace GNSRPC
PROTOBUF_NAMESPACE_OPEN
template<> ::GNSRPC::CardStatus* Arena::CreateMaybeMessage<::GNSRPC::CardStatus>(Arena*);
template<> ::GNSRPC::FreeSites* Arena::CreateMaybeMessage<::GNSRPC::FreeSites>(Arena*);
template<> ::GNSRPC::FreeWinCreds* Arena::CreateMaybeMessage<::GNSRPC::FreeWinCreds>(Arena*);
template<> ::GNSRPC::GNSBadgeDataParam* Arena::CreateMaybeMessage<::GNSRPC::GNSBadgeDataParam>(Arena*);
template<> ::GNSRPC::SiteCred* Arena::CreateMaybeMessage<::GNSRPC::SiteCred>(Arena*);
template<> ::GNSRPC::Sites* Arena::CreateMaybeMessage<::GNSRPC::Sites>(Arena*);
template<> ::GNSRPC::Text* Arena::CreateMaybeMessage<::GNSRPC::Text>(Arena*);
template<> ::GNSRPC::UUID* Arena::CreateMaybeMessage<::GNSRPC::UUID>(Arena*);
template<> ::GNSRPC::WinCred* Arena::CreateMaybeMessage<::GNSRPC::WinCred>(Arena*);
template<> ::GNSRPC::WinCreds* Arena::CreateMaybeMessage<::GNSRPC::WinCreds>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace GNSRPC {

enum CardStatus_ConnectionType : int {
  CardStatus_ConnectionType_USB = 0,
  CardStatus_ConnectionType_NFC = 1,
  CardStatus_ConnectionType_CardStatus_ConnectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CardStatus_ConnectionType_CardStatus_ConnectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CardStatus_ConnectionType_IsValid(int value);
constexpr CardStatus_ConnectionType CardStatus_ConnectionType_ConnectionType_MIN = CardStatus_ConnectionType_USB;
constexpr CardStatus_ConnectionType CardStatus_ConnectionType_ConnectionType_MAX = CardStatus_ConnectionType_NFC;
constexpr int CardStatus_ConnectionType_ConnectionType_ARRAYSIZE = CardStatus_ConnectionType_ConnectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CardStatus_ConnectionType_descriptor();
template<typename T>
inline const std::string& CardStatus_ConnectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CardStatus_ConnectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CardStatus_ConnectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CardStatus_ConnectionType_descriptor(), enum_t_value);
}
inline bool CardStatus_ConnectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CardStatus_ConnectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CardStatus_ConnectionType>(
    CardStatus_ConnectionType_descriptor(), name, value);
}
enum CardStatus_ConnectionStatus : int {
  CardStatus_ConnectionStatus_Disconnected = 0,
  CardStatus_ConnectionStatus_Connected = 1,
  CardStatus_ConnectionStatus_Authenticated = 2,
  CardStatus_ConnectionStatus_UnlockedMode = 3,
  CardStatus_ConnectionStatus_UnlockedModeReady = 4,
  CardStatus_ConnectionStatus_CardStatus_ConnectionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CardStatus_ConnectionStatus_CardStatus_ConnectionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CardStatus_ConnectionStatus_IsValid(int value);
constexpr CardStatus_ConnectionStatus CardStatus_ConnectionStatus_ConnectionStatus_MIN = CardStatus_ConnectionStatus_Disconnected;
constexpr CardStatus_ConnectionStatus CardStatus_ConnectionStatus_ConnectionStatus_MAX = CardStatus_ConnectionStatus_UnlockedModeReady;
constexpr int CardStatus_ConnectionStatus_ConnectionStatus_ARRAYSIZE = CardStatus_ConnectionStatus_ConnectionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CardStatus_ConnectionStatus_descriptor();
template<typename T>
inline const std::string& CardStatus_ConnectionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CardStatus_ConnectionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CardStatus_ConnectionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CardStatus_ConnectionStatus_descriptor(), enum_t_value);
}
inline bool CardStatus_ConnectionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CardStatus_ConnectionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CardStatus_ConnectionStatus>(
    CardStatus_ConnectionStatus_descriptor(), name, value);
}
// ===================================================================

class UUID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.UUID) */ {
 public:
  inline UUID() : UUID(nullptr) {}
  ~UUID() override;
  explicit constexpr UUID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UUID(const UUID& from);
  UUID(UUID&& from) noexcept
    : UUID() {
    *this = ::std::move(from);
  }

  inline UUID& operator=(const UUID& from) {
    CopyFrom(from);
    return *this;
  }
  inline UUID& operator=(UUID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UUID& default_instance() {
    return *internal_default_instance();
  }
  static inline const UUID* internal_default_instance() {
    return reinterpret_cast<const UUID*>(
               &_UUID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UUID& a, UUID& b) {
    a.Swap(&b);
  }
  inline void Swap(UUID* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UUID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UUID* New() const final {
    return new UUID();
  }

  UUID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UUID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UUID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UUID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UUID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.UUID";
  }
  protected:
  explicit UUID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kModeFieldNumber = 2,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_MUST_USE_RESULT std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // uint32 mode = 2;
  void clear_mode();
  ::PROTOBUF_NAMESPACE_ID::uint32 mode() const;
  void set_mode(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_mode() const;
  void _internal_set_mode(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:GNSRPC.UUID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class FreeSites final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.FreeSites) */ {
 public:
  inline FreeSites() : FreeSites(nullptr) {}
  ~FreeSites() override;
  explicit constexpr FreeSites(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreeSites(const FreeSites& from);
  FreeSites(FreeSites&& from) noexcept
    : FreeSites() {
    *this = ::std::move(from);
  }

  inline FreeSites& operator=(const FreeSites& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreeSites& operator=(FreeSites&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreeSites& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreeSites* internal_default_instance() {
    return reinterpret_cast<const FreeSites*>(
               &_FreeSites_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FreeSites& a, FreeSites& b) {
    a.Swap(&b);
  }
  inline void Swap(FreeSites* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreeSites* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreeSites* New() const final {
    return new FreeSites();
  }

  FreeSites* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreeSites>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FreeSites& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FreeSites& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreeSites* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.FreeSites";
  }
  protected:
  explicit FreeSites(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
  };
  // repeated uint32 idx = 1;
  int idx_size() const;
  private:
  int _internal_idx_size() const;
  public:
  void clear_idx();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_idx() const;
  void _internal_add_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_idx();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 idx(int index) const;
  void set_idx(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      idx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_idx();

  // @@protoc_insertion_point(class_scope:GNSRPC.FreeSites)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > idx_;
  mutable std::atomic<int> _idx_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class FreeWinCreds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.FreeWinCreds) */ {
 public:
  inline FreeWinCreds() : FreeWinCreds(nullptr) {}
  ~FreeWinCreds() override;
  explicit constexpr FreeWinCreds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FreeWinCreds(const FreeWinCreds& from);
  FreeWinCreds(FreeWinCreds&& from) noexcept
    : FreeWinCreds() {
    *this = ::std::move(from);
  }

  inline FreeWinCreds& operator=(const FreeWinCreds& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreeWinCreds& operator=(FreeWinCreds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreeWinCreds& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreeWinCreds* internal_default_instance() {
    return reinterpret_cast<const FreeWinCreds*>(
               &_FreeWinCreds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FreeWinCreds& a, FreeWinCreds& b) {
    a.Swap(&b);
  }
  inline void Swap(FreeWinCreds* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreeWinCreds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FreeWinCreds* New() const final {
    return new FreeWinCreds();
  }

  FreeWinCreds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FreeWinCreds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FreeWinCreds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FreeWinCreds& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreeWinCreds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.FreeWinCreds";
  }
  protected:
  explicit FreeWinCreds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
  };
  // repeated uint32 idx = 1;
  int idx_size() const;
  private:
  int _internal_idx_size() const;
  public:
  void clear_idx();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_idx() const;
  void _internal_add_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_idx();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 idx(int index) const;
  void set_idx(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      idx() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_idx();

  // @@protoc_insertion_point(class_scope:GNSRPC.FreeWinCreds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > idx_;
  mutable std::atomic<int> _idx_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class SiteCred final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.SiteCred) */ {
 public:
  inline SiteCred() : SiteCred(nullptr) {}
  ~SiteCred() override;
  explicit constexpr SiteCred(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SiteCred(const SiteCred& from);
  SiteCred(SiteCred&& from) noexcept
    : SiteCred() {
    *this = ::std::move(from);
  }

  inline SiteCred& operator=(const SiteCred& from) {
    CopyFrom(from);
    return *this;
  }
  inline SiteCred& operator=(SiteCred&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SiteCred& default_instance() {
    return *internal_default_instance();
  }
  static inline const SiteCred* internal_default_instance() {
    return reinterpret_cast<const SiteCred*>(
               &_SiteCred_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SiteCred& a, SiteCred& b) {
    a.Swap(&b);
  }
  inline void Swap(SiteCred* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SiteCred* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SiteCred* New() const final {
    return new SiteCred();
  }

  SiteCred* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SiteCred>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SiteCred& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SiteCred& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SiteCred* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.SiteCred";
  }
  protected:
  explicit SiteCred(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 3,
    kUsernameFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kMiscFieldNumber = 6,
    kIdxFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // string code = 3;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 5;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string misc = 6;
  void clear_misc();
  const std::string& misc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_misc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_misc();
  PROTOBUF_MUST_USE_RESULT std::string* release_misc();
  void set_allocated_misc(std::string* misc);
  private:
  const std::string& _internal_misc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_misc(const std::string& value);
  std::string* _internal_mutable_misc();
  public:

  // uint32 idx = 1;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 offset = 2;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:GNSRPC.SiteCred)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr misc_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  ::PROTOBUF_NAMESPACE_ID::uint32 offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class Sites final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.Sites) */ {
 public:
  inline Sites() : Sites(nullptr) {}
  ~Sites() override;
  explicit constexpr Sites(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sites(const Sites& from);
  Sites(Sites&& from) noexcept
    : Sites() {
    *this = ::std::move(from);
  }

  inline Sites& operator=(const Sites& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sites& operator=(Sites&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sites& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sites* internal_default_instance() {
    return reinterpret_cast<const Sites*>(
               &_Sites_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Sites& a, Sites& b) {
    a.Swap(&b);
  }
  inline void Swap(Sites* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sites* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Sites* New() const final {
    return new Sites();
  }

  Sites* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Sites>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sites& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Sites& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sites* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.Sites";
  }
  protected:
  explicit Sites(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSitesFieldNumber = 1,
  };
  // repeated .GNSRPC.SiteCred sites = 1;
  int sites_size() const;
  private:
  int _internal_sites_size() const;
  public:
  void clear_sites();
  ::GNSRPC::SiteCred* mutable_sites(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::SiteCred >*
      mutable_sites();
  private:
  const ::GNSRPC::SiteCred& _internal_sites(int index) const;
  ::GNSRPC::SiteCred* _internal_add_sites();
  public:
  const ::GNSRPC::SiteCred& sites(int index) const;
  ::GNSRPC::SiteCred* add_sites();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::SiteCred >&
      sites() const;

  // @@protoc_insertion_point(class_scope:GNSRPC.Sites)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::SiteCred > sites_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class WinCred final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.WinCred) */ {
 public:
  inline WinCred() : WinCred(nullptr) {}
  ~WinCred() override;
  explicit constexpr WinCred(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WinCred(const WinCred& from);
  WinCred(WinCred&& from) noexcept
    : WinCred() {
    *this = ::std::move(from);
  }

  inline WinCred& operator=(const WinCred& from) {
    CopyFrom(from);
    return *this;
  }
  inline WinCred& operator=(WinCred&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WinCred& default_instance() {
    return *internal_default_instance();
  }
  static inline const WinCred* internal_default_instance() {
    return reinterpret_cast<const WinCred*>(
               &_WinCred_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WinCred& a, WinCred& b) {
    a.Swap(&b);
  }
  inline void Swap(WinCred* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WinCred* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WinCred* New() const final {
    return new WinCred();
  }

  WinCred* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WinCred>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WinCred& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WinCred& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WinCred* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.WinCred";
  }
  protected:
  explicit WinCred(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kIdxFieldNumber = 1,
  };
  // string domain = 2;
  void clear_domain();
  const std::string& domain() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_domain(ArgT0&& arg0, ArgT... args);
  std::string* mutable_domain();
  PROTOBUF_MUST_USE_RESULT std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // string username = 3;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // uint32 idx = 1;
  void clear_idx();
  ::PROTOBUF_NAMESPACE_ID::uint32 idx() const;
  void set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_idx() const;
  void _internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:GNSRPC.WinCred)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::uint32 idx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class WinCreds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.WinCreds) */ {
 public:
  inline WinCreds() : WinCreds(nullptr) {}
  ~WinCreds() override;
  explicit constexpr WinCreds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WinCreds(const WinCreds& from);
  WinCreds(WinCreds&& from) noexcept
    : WinCreds() {
    *this = ::std::move(from);
  }

  inline WinCreds& operator=(const WinCreds& from) {
    CopyFrom(from);
    return *this;
  }
  inline WinCreds& operator=(WinCreds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WinCreds& default_instance() {
    return *internal_default_instance();
  }
  static inline const WinCreds* internal_default_instance() {
    return reinterpret_cast<const WinCreds*>(
               &_WinCreds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WinCreds& a, WinCreds& b) {
    a.Swap(&b);
  }
  inline void Swap(WinCreds* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WinCreds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WinCreds* New() const final {
    return new WinCreds();
  }

  WinCreds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WinCreds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WinCreds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WinCreds& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WinCreds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.WinCreds";
  }
  protected:
  explicit WinCreds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWincredsFieldNumber = 1,
  };
  // repeated .GNSRPC.WinCred wincreds = 1;
  int wincreds_size() const;
  private:
  int _internal_wincreds_size() const;
  public:
  void clear_wincreds();
  ::GNSRPC::WinCred* mutable_wincreds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::WinCred >*
      mutable_wincreds();
  private:
  const ::GNSRPC::WinCred& _internal_wincreds(int index) const;
  ::GNSRPC::WinCred* _internal_add_wincreds();
  public:
  const ::GNSRPC::WinCred& wincreds(int index) const;
  ::GNSRPC::WinCred* add_wincreds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::WinCred >&
      wincreds() const;

  // @@protoc_insertion_point(class_scope:GNSRPC.WinCreds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::WinCred > wincreds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class CardStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.CardStatus) */ {
 public:
  inline CardStatus() : CardStatus(nullptr) {}
  ~CardStatus() override;
  explicit constexpr CardStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CardStatus(const CardStatus& from);
  CardStatus(CardStatus&& from) noexcept
    : CardStatus() {
    *this = ::std::move(from);
  }

  inline CardStatus& operator=(const CardStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CardStatus& operator=(CardStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CardStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CardStatus* internal_default_instance() {
    return reinterpret_cast<const CardStatus*>(
               &_CardStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CardStatus& a, CardStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CardStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CardStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CardStatus* New() const final {
    return new CardStatus();
  }

  CardStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CardStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CardStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CardStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CardStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.CardStatus";
  }
  protected:
  explicit CardStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CardStatus_ConnectionType ConnectionType;
  static constexpr ConnectionType USB =
    CardStatus_ConnectionType_USB;
  static constexpr ConnectionType NFC =
    CardStatus_ConnectionType_NFC;
  static inline bool ConnectionType_IsValid(int value) {
    return CardStatus_ConnectionType_IsValid(value);
  }
  static constexpr ConnectionType ConnectionType_MIN =
    CardStatus_ConnectionType_ConnectionType_MIN;
  static constexpr ConnectionType ConnectionType_MAX =
    CardStatus_ConnectionType_ConnectionType_MAX;
  static constexpr int ConnectionType_ARRAYSIZE =
    CardStatus_ConnectionType_ConnectionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConnectionType_descriptor() {
    return CardStatus_ConnectionType_descriptor();
  }
  template<typename T>
  static inline const std::string& ConnectionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionType_Name.");
    return CardStatus_ConnectionType_Name(enum_t_value);
  }
  static inline bool ConnectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionType* value) {
    return CardStatus_ConnectionType_Parse(name, value);
  }

  typedef CardStatus_ConnectionStatus ConnectionStatus;
  static constexpr ConnectionStatus Disconnected =
    CardStatus_ConnectionStatus_Disconnected;
  static constexpr ConnectionStatus Connected =
    CardStatus_ConnectionStatus_Connected;
  static constexpr ConnectionStatus Authenticated =
    CardStatus_ConnectionStatus_Authenticated;
  static constexpr ConnectionStatus UnlockedMode =
    CardStatus_ConnectionStatus_UnlockedMode;
  static constexpr ConnectionStatus UnlockedModeReady =
    CardStatus_ConnectionStatus_UnlockedModeReady;
  static inline bool ConnectionStatus_IsValid(int value) {
    return CardStatus_ConnectionStatus_IsValid(value);
  }
  static constexpr ConnectionStatus ConnectionStatus_MIN =
    CardStatus_ConnectionStatus_ConnectionStatus_MIN;
  static constexpr ConnectionStatus ConnectionStatus_MAX =
    CardStatus_ConnectionStatus_ConnectionStatus_MAX;
  static constexpr int ConnectionStatus_ARRAYSIZE =
    CardStatus_ConnectionStatus_ConnectionStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ConnectionStatus_descriptor() {
    return CardStatus_ConnectionStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ConnectionStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ConnectionStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ConnectionStatus_Name.");
    return CardStatus_ConnectionStatus_Name(enum_t_value);
  }
  static inline bool ConnectionStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ConnectionStatus* value) {
    return CardStatus_ConnectionStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .GNSRPC.CardStatus.ConnectionType type = 1;
  void clear_type();
  ::GNSRPC::CardStatus_ConnectionType type() const;
  void set_type(::GNSRPC::CardStatus_ConnectionType value);
  private:
  ::GNSRPC::CardStatus_ConnectionType _internal_type() const;
  void _internal_set_type(::GNSRPC::CardStatus_ConnectionType value);
  public:

  // .GNSRPC.CardStatus.ConnectionStatus status = 2;
  void clear_status();
  ::GNSRPC::CardStatus_ConnectionStatus status() const;
  void set_status(::GNSRPC::CardStatus_ConnectionStatus value);
  private:
  ::GNSRPC::CardStatus_ConnectionStatus _internal_status() const;
  void _internal_set_status(::GNSRPC::CardStatus_ConnectionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:GNSRPC.CardStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class Text final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GNSRPC.Text) */ {
 public:
  inline Text() : Text(nullptr) {}
  ~Text() override;
  explicit constexpr Text(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Text(const Text& from);
  Text(Text&& from) noexcept
    : Text() {
    *this = ::std::move(from);
  }

  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  inline Text& operator=(Text&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Text& default_instance() {
    return *internal_default_instance();
  }
  static inline const Text* internal_default_instance() {
    return reinterpret_cast<const Text*>(
               &_Text_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Text& a, Text& b) {
    a.Swap(&b);
  }
  inline void Swap(Text* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Text* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Text* New() const final {
    return new Text();
  }

  Text* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Text>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Text& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Text& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Text* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.Text";
  }
  protected:
  explicit Text(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // string text = 1;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_MUST_USE_RESULT std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:GNSRPC.Text)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// -------------------------------------------------------------------

class GNSBadgeDataParam final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:GNSRPC.GNSBadgeDataParam) */ {
 public:
  inline GNSBadgeDataParam() : GNSBadgeDataParam(nullptr) {}
  explicit constexpr GNSBadgeDataParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GNSBadgeDataParam(const GNSBadgeDataParam& from);
  GNSBadgeDataParam(GNSBadgeDataParam&& from) noexcept
    : GNSBadgeDataParam() {
    *this = ::std::move(from);
  }

  inline GNSBadgeDataParam& operator=(const GNSBadgeDataParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline GNSBadgeDataParam& operator=(GNSBadgeDataParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GNSBadgeDataParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const GNSBadgeDataParam* internal_default_instance() {
    return reinterpret_cast<const GNSBadgeDataParam*>(
               &_GNSBadgeDataParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GNSBadgeDataParam& a, GNSBadgeDataParam& b) {
    a.Swap(&b);
  }
  inline void Swap(GNSBadgeDataParam* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GNSBadgeDataParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GNSBadgeDataParam* New() const final {
    return new GNSBadgeDataParam();
  }

  GNSBadgeDataParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GNSBadgeDataParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GNSBadgeDataParam& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GNSBadgeDataParam& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GNSRPC.GNSBadgeDataParam";
  }
  protected:
  explicit GNSBadgeDataParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:GNSRPC.GNSBadgeDataParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnsservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UUID

// string uuid = 1;
inline void UUID::clear_uuid() {
  uuid_.ClearToEmpty();
}
inline const std::string& UUID::uuid() const {
  // @@protoc_insertion_point(field_get:GNSRPC.UUID.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UUID::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.UUID.uuid)
}
inline std::string* UUID::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:GNSRPC.UUID.uuid)
  return _s;
}
inline const std::string& UUID::_internal_uuid() const {
  return uuid_.Get();
}
inline void UUID::_internal_set_uuid(const std::string& value) {
  
  uuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UUID::_internal_mutable_uuid() {
  
  return uuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UUID::release_uuid() {
  // @@protoc_insertion_point(field_release:GNSRPC.UUID.uuid)
  return uuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UUID::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  uuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uuid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.UUID.uuid)
}

// uint32 mode = 2;
inline void UUID::clear_mode() {
  mode_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UUID::_internal_mode() const {
  return mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UUID::mode() const {
  // @@protoc_insertion_point(field_get:GNSRPC.UUID.mode)
  return _internal_mode();
}
inline void UUID::_internal_set_mode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  mode_ = value;
}
inline void UUID::set_mode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:GNSRPC.UUID.mode)
}

// -------------------------------------------------------------------

// FreeSites

// repeated uint32 idx = 1;
inline int FreeSites::_internal_idx_size() const {
  return idx_.size();
}
inline int FreeSites::idx_size() const {
  return _internal_idx_size();
}
inline void FreeSites::clear_idx() {
  idx_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FreeSites::_internal_idx(int index) const {
  return idx_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FreeSites::idx(int index) const {
  // @@protoc_insertion_point(field_get:GNSRPC.FreeSites.idx)
  return _internal_idx(index);
}
inline void FreeSites::set_idx(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  idx_.Set(index, value);
  // @@protoc_insertion_point(field_set:GNSRPC.FreeSites.idx)
}
inline void FreeSites::_internal_add_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  idx_.Add(value);
}
inline void FreeSites::add_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_idx(value);
  // @@protoc_insertion_point(field_add:GNSRPC.FreeSites.idx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
FreeSites::_internal_idx() const {
  return idx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
FreeSites::idx() const {
  // @@protoc_insertion_point(field_list:GNSRPC.FreeSites.idx)
  return _internal_idx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
FreeSites::_internal_mutable_idx() {
  return &idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
FreeSites::mutable_idx() {
  // @@protoc_insertion_point(field_mutable_list:GNSRPC.FreeSites.idx)
  return _internal_mutable_idx();
}

// -------------------------------------------------------------------

// FreeWinCreds

// repeated uint32 idx = 1;
inline int FreeWinCreds::_internal_idx_size() const {
  return idx_.size();
}
inline int FreeWinCreds::idx_size() const {
  return _internal_idx_size();
}
inline void FreeWinCreds::clear_idx() {
  idx_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FreeWinCreds::_internal_idx(int index) const {
  return idx_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FreeWinCreds::idx(int index) const {
  // @@protoc_insertion_point(field_get:GNSRPC.FreeWinCreds.idx)
  return _internal_idx(index);
}
inline void FreeWinCreds::set_idx(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  idx_.Set(index, value);
  // @@protoc_insertion_point(field_set:GNSRPC.FreeWinCreds.idx)
}
inline void FreeWinCreds::_internal_add_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  idx_.Add(value);
}
inline void FreeWinCreds::add_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_idx(value);
  // @@protoc_insertion_point(field_add:GNSRPC.FreeWinCreds.idx)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
FreeWinCreds::_internal_idx() const {
  return idx_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
FreeWinCreds::idx() const {
  // @@protoc_insertion_point(field_list:GNSRPC.FreeWinCreds.idx)
  return _internal_idx();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
FreeWinCreds::_internal_mutable_idx() {
  return &idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
FreeWinCreds::mutable_idx() {
  // @@protoc_insertion_point(field_mutable_list:GNSRPC.FreeWinCreds.idx)
  return _internal_mutable_idx();
}

// -------------------------------------------------------------------

// SiteCred

// uint32 idx = 1;
inline void SiteCred::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SiteCred::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SiteCred::idx() const {
  // @@protoc_insertion_point(field_get:GNSRPC.SiteCred.idx)
  return _internal_idx();
}
inline void SiteCred::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void SiteCred::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:GNSRPC.SiteCred.idx)
}

// uint32 offset = 2;
inline void SiteCred::clear_offset() {
  offset_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SiteCred::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SiteCred::offset() const {
  // @@protoc_insertion_point(field_get:GNSRPC.SiteCred.offset)
  return _internal_offset();
}
inline void SiteCred::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  offset_ = value;
}
inline void SiteCred::set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:GNSRPC.SiteCred.offset)
}

// string code = 3;
inline void SiteCred::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& SiteCred::code() const {
  // @@protoc_insertion_point(field_get:GNSRPC.SiteCred.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SiteCred::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.SiteCred.code)
}
inline std::string* SiteCred::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:GNSRPC.SiteCred.code)
  return _s;
}
inline const std::string& SiteCred::_internal_code() const {
  return code_.Get();
}
inline void SiteCred::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SiteCred::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SiteCred::release_code() {
  // @@protoc_insertion_point(field_release:GNSRPC.SiteCred.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SiteCred::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.SiteCred.code)
}

// string username = 4;
inline void SiteCred::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& SiteCred::username() const {
  // @@protoc_insertion_point(field_get:GNSRPC.SiteCred.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SiteCred::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.SiteCred.username)
}
inline std::string* SiteCred::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:GNSRPC.SiteCred.username)
  return _s;
}
inline const std::string& SiteCred::_internal_username() const {
  return username_.Get();
}
inline void SiteCred::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SiteCred::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SiteCred::release_username() {
  // @@protoc_insertion_point(field_release:GNSRPC.SiteCred.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SiteCred::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.SiteCred.username)
}

// string password = 5;
inline void SiteCred::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& SiteCred::password() const {
  // @@protoc_insertion_point(field_get:GNSRPC.SiteCred.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SiteCred::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.SiteCred.password)
}
inline std::string* SiteCred::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:GNSRPC.SiteCred.password)
  return _s;
}
inline const std::string& SiteCred::_internal_password() const {
  return password_.Get();
}
inline void SiteCred::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SiteCred::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SiteCred::release_password() {
  // @@protoc_insertion_point(field_release:GNSRPC.SiteCred.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SiteCred::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.SiteCred.password)
}

// string misc = 6;
inline void SiteCred::clear_misc() {
  misc_.ClearToEmpty();
}
inline const std::string& SiteCred::misc() const {
  // @@protoc_insertion_point(field_get:GNSRPC.SiteCred.misc)
  return _internal_misc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SiteCred::set_misc(ArgT0&& arg0, ArgT... args) {
 
 misc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.SiteCred.misc)
}
inline std::string* SiteCred::mutable_misc() {
  std::string* _s = _internal_mutable_misc();
  // @@protoc_insertion_point(field_mutable:GNSRPC.SiteCred.misc)
  return _s;
}
inline const std::string& SiteCred::_internal_misc() const {
  return misc_.Get();
}
inline void SiteCred::_internal_set_misc(const std::string& value) {
  
  misc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SiteCred::_internal_mutable_misc() {
  
  return misc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SiteCred::release_misc() {
  // @@protoc_insertion_point(field_release:GNSRPC.SiteCred.misc)
  return misc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SiteCred::set_allocated_misc(std::string* misc) {
  if (misc != nullptr) {
    
  } else {
    
  }
  misc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), misc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.SiteCred.misc)
}

// -------------------------------------------------------------------

// Sites

// repeated .GNSRPC.SiteCred sites = 1;
inline int Sites::_internal_sites_size() const {
  return sites_.size();
}
inline int Sites::sites_size() const {
  return _internal_sites_size();
}
inline void Sites::clear_sites() {
  sites_.Clear();
}
inline ::GNSRPC::SiteCred* Sites::mutable_sites(int index) {
  // @@protoc_insertion_point(field_mutable:GNSRPC.Sites.sites)
  return sites_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::SiteCred >*
Sites::mutable_sites() {
  // @@protoc_insertion_point(field_mutable_list:GNSRPC.Sites.sites)
  return &sites_;
}
inline const ::GNSRPC::SiteCred& Sites::_internal_sites(int index) const {
  return sites_.Get(index);
}
inline const ::GNSRPC::SiteCred& Sites::sites(int index) const {
  // @@protoc_insertion_point(field_get:GNSRPC.Sites.sites)
  return _internal_sites(index);
}
inline ::GNSRPC::SiteCred* Sites::_internal_add_sites() {
  return sites_.Add();
}
inline ::GNSRPC::SiteCred* Sites::add_sites() {
  ::GNSRPC::SiteCred* _add = _internal_add_sites();
  // @@protoc_insertion_point(field_add:GNSRPC.Sites.sites)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::SiteCred >&
Sites::sites() const {
  // @@protoc_insertion_point(field_list:GNSRPC.Sites.sites)
  return sites_;
}

// -------------------------------------------------------------------

// WinCred

// uint32 idx = 1;
inline void WinCred::clear_idx() {
  idx_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WinCred::_internal_idx() const {
  return idx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WinCred::idx() const {
  // @@protoc_insertion_point(field_get:GNSRPC.WinCred.idx)
  return _internal_idx();
}
inline void WinCred::_internal_set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  idx_ = value;
}
inline void WinCred::set_idx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_idx(value);
  // @@protoc_insertion_point(field_set:GNSRPC.WinCred.idx)
}

// string domain = 2;
inline void WinCred::clear_domain() {
  domain_.ClearToEmpty();
}
inline const std::string& WinCred::domain() const {
  // @@protoc_insertion_point(field_get:GNSRPC.WinCred.domain)
  return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WinCred::set_domain(ArgT0&& arg0, ArgT... args) {
 
 domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.WinCred.domain)
}
inline std::string* WinCred::mutable_domain() {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:GNSRPC.WinCred.domain)
  return _s;
}
inline const std::string& WinCred::_internal_domain() const {
  return domain_.Get();
}
inline void WinCred::_internal_set_domain(const std::string& value) {
  
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WinCred::_internal_mutable_domain() {
  
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WinCred::release_domain() {
  // @@protoc_insertion_point(field_release:GNSRPC.WinCred.domain)
  return domain_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WinCred::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.WinCred.domain)
}

// string username = 3;
inline void WinCred::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& WinCred::username() const {
  // @@protoc_insertion_point(field_get:GNSRPC.WinCred.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WinCred::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.WinCred.username)
}
inline std::string* WinCred::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:GNSRPC.WinCred.username)
  return _s;
}
inline const std::string& WinCred::_internal_username() const {
  return username_.Get();
}
inline void WinCred::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WinCred::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WinCred::release_username() {
  // @@protoc_insertion_point(field_release:GNSRPC.WinCred.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WinCred::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.WinCred.username)
}

// string password = 4;
inline void WinCred::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& WinCred::password() const {
  // @@protoc_insertion_point(field_get:GNSRPC.WinCred.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WinCred::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.WinCred.password)
}
inline std::string* WinCred::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:GNSRPC.WinCred.password)
  return _s;
}
inline const std::string& WinCred::_internal_password() const {
  return password_.Get();
}
inline void WinCred::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WinCred::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WinCred::release_password() {
  // @@protoc_insertion_point(field_release:GNSRPC.WinCred.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WinCred::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.WinCred.password)
}

// -------------------------------------------------------------------

// WinCreds

// repeated .GNSRPC.WinCred wincreds = 1;
inline int WinCreds::_internal_wincreds_size() const {
  return wincreds_.size();
}
inline int WinCreds::wincreds_size() const {
  return _internal_wincreds_size();
}
inline void WinCreds::clear_wincreds() {
  wincreds_.Clear();
}
inline ::GNSRPC::WinCred* WinCreds::mutable_wincreds(int index) {
  // @@protoc_insertion_point(field_mutable:GNSRPC.WinCreds.wincreds)
  return wincreds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::WinCred >*
WinCreds::mutable_wincreds() {
  // @@protoc_insertion_point(field_mutable_list:GNSRPC.WinCreds.wincreds)
  return &wincreds_;
}
inline const ::GNSRPC::WinCred& WinCreds::_internal_wincreds(int index) const {
  return wincreds_.Get(index);
}
inline const ::GNSRPC::WinCred& WinCreds::wincreds(int index) const {
  // @@protoc_insertion_point(field_get:GNSRPC.WinCreds.wincreds)
  return _internal_wincreds(index);
}
inline ::GNSRPC::WinCred* WinCreds::_internal_add_wincreds() {
  return wincreds_.Add();
}
inline ::GNSRPC::WinCred* WinCreds::add_wincreds() {
  ::GNSRPC::WinCred* _add = _internal_add_wincreds();
  // @@protoc_insertion_point(field_add:GNSRPC.WinCreds.wincreds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GNSRPC::WinCred >&
WinCreds::wincreds() const {
  // @@protoc_insertion_point(field_list:GNSRPC.WinCreds.wincreds)
  return wincreds_;
}

// -------------------------------------------------------------------

// CardStatus

// .GNSRPC.CardStatus.ConnectionType type = 1;
inline void CardStatus::clear_type() {
  type_ = 0;
}
inline ::GNSRPC::CardStatus_ConnectionType CardStatus::_internal_type() const {
  return static_cast< ::GNSRPC::CardStatus_ConnectionType >(type_);
}
inline ::GNSRPC::CardStatus_ConnectionType CardStatus::type() const {
  // @@protoc_insertion_point(field_get:GNSRPC.CardStatus.type)
  return _internal_type();
}
inline void CardStatus::_internal_set_type(::GNSRPC::CardStatus_ConnectionType value) {
  
  type_ = value;
}
inline void CardStatus::set_type(::GNSRPC::CardStatus_ConnectionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:GNSRPC.CardStatus.type)
}

// .GNSRPC.CardStatus.ConnectionStatus status = 2;
inline void CardStatus::clear_status() {
  status_ = 0;
}
inline ::GNSRPC::CardStatus_ConnectionStatus CardStatus::_internal_status() const {
  return static_cast< ::GNSRPC::CardStatus_ConnectionStatus >(status_);
}
inline ::GNSRPC::CardStatus_ConnectionStatus CardStatus::status() const {
  // @@protoc_insertion_point(field_get:GNSRPC.CardStatus.status)
  return _internal_status();
}
inline void CardStatus::_internal_set_status(::GNSRPC::CardStatus_ConnectionStatus value) {
  
  status_ = value;
}
inline void CardStatus::set_status(::GNSRPC::CardStatus_ConnectionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:GNSRPC.CardStatus.status)
}

// -------------------------------------------------------------------

// Text

// string text = 1;
inline void Text::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& Text::text() const {
  // @@protoc_insertion_point(field_get:GNSRPC.Text.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Text::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GNSRPC.Text.text)
}
inline std::string* Text::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:GNSRPC.Text.text)
  return _s;
}
inline const std::string& Text::_internal_text() const {
  return text_.Get();
}
inline void Text::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Text::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Text::release_text() {
  // @@protoc_insertion_point(field_release:GNSRPC.Text.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Text::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:GNSRPC.Text.text)
}

// -------------------------------------------------------------------

// GNSBadgeDataParam

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace GNSRPC

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::GNSRPC::CardStatus_ConnectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GNSRPC::CardStatus_ConnectionType>() {
  return ::GNSRPC::CardStatus_ConnectionType_descriptor();
}
template <> struct is_proto_enum< ::GNSRPC::CardStatus_ConnectionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GNSRPC::CardStatus_ConnectionStatus>() {
  return ::GNSRPC::CardStatus_ConnectionStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gnsservice_2eproto
